<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Cpp Concurrency in Action Note | Yaohai's Blog</title><meta name="author" content="Yaohai Zhou"><meta name="copyright" content="Yaohai Zhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Ch3: Sharing data between threads This charpter mainly illustrates three points: problems with sharing data between threads, protecting shared data with mutexes and alternative facilities for protecti">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp Concurrency in Action Note">
<meta property="og:url" content="http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/index.html">
<meta property="og:site_name" content="Yaohai&#39;s Blog">
<meta property="og:description" content="Ch3: Sharing data between threads This charpter mainly illustrates three points: problems with sharing data between threads, protecting shared data with mutexes and alternative facilities for protecti">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/CCIA.jpg">
<meta property="article:published_time" content="2023-01-06T00:43:08.000Z">
<meta property="article:modified_time" content="2023-01-07T02:11:41.099Z">
<meta property="article:author" content="Yaohai Zhou">
<meta property="article:tag" content="Book">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/CCIA.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cpp Concurrency in Action Note',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-06 18:11:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/2023/01/05/Cpp-Concurrency-in-Action-Note/CCIA.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Yaohai's Blog</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Cpp Concurrency in Action Note</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-06T00:43:08.000Z" title="Created 2023-01-05 16:43:08">2023-01-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-01-07T02:11:41.099Z" title="Updated 2023-01-06 18:11:41">2023-01-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Cpp Concurrency in Action Note"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ch3-sharing-data-between-threads">Ch3: Sharing data between
threads</h1>
<p>This charpter mainly illustrates three points: <strong>problems with
sharing data between threads, protecting shared data with mutexes and
alternative facilities for protecting shared data</strong>.</p>
<h2 id="problems-with-sharing-data-between-threads">Problems with
sharing data between threads</h2>
<p>When it comes down to it, the problems with sharing data between
threads are all due to the consequences of modifying data. We call this
<strong>race condition</strong>.</p>
<p>The simplest way to solve race conditions is that we can wrap the
data with a protection mechanism to ensure that only the thread
performing a modification can see the intermediate states. In other
words, other threads cannot access the data when the protected thread is
running. C++ implements this protection mechanism as <strong>mutex and
lock</strong>.</p>
<h2 id="protecting-shared-data-with-mutexes">Protecting shared data with
mutexes</h2>
<p>mutex (mutual exclusion) is a synchronization primitive in C++.
Before accessing a shared data structure, we lock the mutex associated
with that data, and when we’ve finished accessing the data structure, we
unlock the mutex. There are two common lock class in C++: lock_guard and
unique_lock.</p>
<ol type="1">
<li><code>std::lock_guard&lt;std::mutex&gt;</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; some_list;    </span><br><span class="line">std::mutex some_mutex;        </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_list</span><span class="params">(<span class="type">int</span> new_value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;       </span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">list_contains</span><span class="params">(<span class="type">int</span> value_to_find)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;       </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find)!= some_list.<span class="built_in">end</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It automatically locks the supplied mutex on construction and unlocks
it on destruction.</p>
<ol start="2" type="1">
<li><code>std::unique_lock&lt;std::mutex&gt;</code></li>
</ol>
<p>std::unique_lock provides a bit more flexibility than std::lock_guard
by relaxing the invariants; an std::unique_lock instance doesn’t always
own the mutex that it’s associated with.</p>
<p>For example, we can let the mutex remain unlocked on
construction.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>;</span><br><span class="line">lock_a.<span class="built_in">lock</span>();</span><br></pre></td></tr></table></figure>
<p>We can unlock the mutex. This is common for time-consuming tasks such
as file I/O.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_data</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;     </span><br><span class="line">  some_class data_to_process=<span class="built_in">get_next_data_chunk</span>();     </span><br><span class="line">  my_lock.<span class="built_in">unlock</span>();                                     </span><br><span class="line">  result_type result=<span class="built_in">process</span>(data_to_process);     </span><br><span class="line">  my_lock.<span class="built_in">lock</span>();                                  </span><br><span class="line">  <span class="built_in">write_result</span>(data_to_process,result); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Also we can transfer the ownership of the lock between functions.
<code>process_data()</code>can do something under the protection of the
lock.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">extern</span> std::mutex some_mutex;     </span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;     </span><br><span class="line">  <span class="built_in">prepare_data</span>();     </span><br><span class="line">  <span class="keyword">return</span> lk;        </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;        </span><br><span class="line">  <span class="built_in">do_something</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="alternative-facilities-for-protecting-shared-data">Alternative
facilities for protecting shared data</h2>
<ol type="1">
<li><code>std::call_once</code></li>
</ol>
<p>Let's say, if we have a data structure to be initialized in a
function and many threads may run the function and do the initilization
simultaneously. If we only expect the initilization to happen once, we
can use <code>std::call_once</code>. The pointer will only be
initialized by one thread when std::call_once returns.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr; </span><br><span class="line">std::once_flag resource_flag;        </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_resource</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);    </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  std::<span class="built_in">call_once</span>(resource_flag,init_resource);<span class="comment">//pass the flag and init function</span></span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>reader-writer mutex</li>
</ol>
<p>If we want to protect rarely updated data structures, which means we
read them often but write to them rarely, we can use reader-writer
mutex. This is a new feature for C++17. The C++17 Standard Library
provides two such mutexes, <code>std:: shared_mutex</code> and
<code>std::shared_timed_mutex</code>.</p>
<h1 id="ch4-synchronizing-concurrent-operations">Ch4: Synchronizing
concurrent operations</h1>
<p>There are four main points in this chapter: <strong>Waiting for an
event or other condition, Waiting for one-off events with futures,
Waiting with a time limit and Using synchronization of operations to
simplify code</strong>.</p>
<h2 id="waiting-for-an-event-or-other-condition">Waiting for an event or
other condition</h2>
<p>The most basic mechanism for waiting for an event to be triggered by
another thread is the <strong>condition variable</strong>. A condition
variable is associated with an event or other condition, and one or more
threads can wait for that condition to be satisfied. When a thread has
determined that the condition is satisfied, it can then notify one or
more of the threads waiting on the condition variable in order to wake
them up and allow them to continue processing.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mut; </span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;      </span><br><span class="line">std::condition_variable data_cond; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())     </span><br><span class="line">  &#123;         </span><br><span class="line">    data_chunk <span class="type">const</span> data=<span class="built_in">prepare_data</span>();         </span><br><span class="line">    &#123;             </span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;             </span><br><span class="line">      data_queue.<span class="built_in">push</span>(data);                      </span><br><span class="line">    &#125;         </span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();   </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)     </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;            </span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);<span class="comment">//it wakes up when notify_one() is called. </span></span><br><span class="line">    <span class="comment">//If !data_queue.empty() is true, the program will continue with mutex locked. </span></span><br><span class="line">    <span class="comment">//Otherwise, it will release the lock and block here. This is called a spurious wake.</span></span><br><span class="line">    data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actually, we can follow the pattern and implement a Producer-Consumer
multithread version.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; m_data;</span><br><span class="line">    std::atomic_bool m_bFinished;</span><br><span class="line">    std::mutex m_Mutex;</span><br><span class="line">    std::condition_variable m_cv;</span><br><span class="line">    <span class="type">int</span> m_QueueSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">App</span>(<span class="type">int</span> MaxQueue) </span><br><span class="line">        : <span class="built_in">m_bFinished</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">m_QueueSize</span>(MaxQueue) </span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_QueueSize; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>;</span><br><span class="line">                m_data.<span class="built_in">push</span>(i); </span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Producer Thread, queue element: &quot;</span>&lt;&lt; m_data.<span class="built_in">back</span>() &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; m_data.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">            m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_bFinished = <span class="literal">true</span>;<span class="comment">//indicate producer has finished</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Consumer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">do</span><span class="comment">//consumer wait for new items until producer stops producing</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_Mutex)</span></span>;</span><br><span class="line">            m_cv.<span class="built_in">wait</span>(lock, [&amp;]()&#123; <span class="keyword">return</span> !m_data.<span class="built_in">empty</span>(); &#125;); <span class="comment">// predicate an while loop - protection from spurious wakeups</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!m_data.<span class="built_in">empty</span>()) <span class="comment">// consume all elements from queue</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Consumer Thread, queue element: &quot;</span> &lt;&lt; m_data.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; size: &quot;</span> &lt;&lt; m_data.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">                m_data.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!m_bFinished);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> QueueElements = <span class="number">10</span>;</span><br><span class="line">    <span class="function">App <span class="title">app</span><span class="params">(QueueElements)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer_thread</span><span class="params">(&amp;App::Consumer, &amp;app)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer_thread</span><span class="params">(&amp;App::Producer, &amp;app)</span></span>;</span><br><span class="line"></span><br><span class="line">    producer_thread.<span class="built_in">join</span>();</span><br><span class="line">    consumer_thread.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;loop exited&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is the output of above program.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Producer Thread, queue element: <span class="number">0</span> size: <span class="number">1</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">0</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">1</span> size: <span class="number">1</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">1</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">2</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">3</span> size: <span class="number">2</span></span><br><span class="line">Producer Thread, queue element: <span class="number">4</span> size: <span class="number">3</span></span><br><span class="line">Producer Thread, queue element: <span class="number">5</span> size: <span class="number">4</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">2</span> size: <span class="number">4</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">3</span> size: <span class="number">3</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">4</span> size: <span class="number">2</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">5</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">6</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">7</span> size: <span class="number">2</span></span><br><span class="line">Producer Thread, queue element: <span class="number">8</span> size: <span class="number">3</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">6</span> size: <span class="number">3</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">7</span> size: <span class="number">2</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">8</span> size: <span class="number">1</span></span><br><span class="line">Producer Thread, queue element: <span class="number">9</span> size: <span class="number">1</span></span><br><span class="line">	Consumer Thread, queue element: <span class="number">9</span> size: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="waiting-for-one-off-events-with-futures">Waiting for one-off
events with futures</h2>
<p>If a thread needs to wait for a specific one-off event, it somehow
obtains a <strong>std::future</strong> representing that event. It can
do another task until it needs the event to have happened before it can
proceed and then just wait for the future to become ready. Once an event
has happened (and the future has become ready), the future can’t be
reset.</p>
<ol type="1">
<li>Returning values from background tasks</li>
</ol>
<p>You use <strong>std::async</strong> to start an asynchronous task for
which you don’t need the result right away. std::async returns a
std::future object, which will eventually hold the return value of the
function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; the_answer=std::<span class="built_in">async</span>(find_the_answer_to_ltuae);     </span><br><span class="line">  <span class="built_in">do_other_stuff</span>();     </span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>Associating a task with a future</li>
</ol>
<p><strong>std::packaged_task&lt;&gt;</strong> ties a future to a
function or callable object. When the std:: packaged_task&lt;&gt; object
is invoked, it calls the associated function or callable object and
makes the future ready, with the return value stored as the associated
data.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> </span></span><br><span class="line">std::mutex m; </span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="type">void</span>()&gt; &gt; tasks; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gui_thread</span><span class="params">()</span>                   </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())       </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();            </span><br><span class="line">    std::packaged_task&lt;<span class="built_in">void</span>()&gt; task;         </span><br><span class="line">    &#123;             </span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;             </span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())                                 </span><br><span class="line">        <span class="keyword">continue</span>;             </span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());               </span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="built_in">task</span>();        </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt; </span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;           </span><br><span class="line">  std::future&lt;<span class="type">void</span>&gt; res=task.<span class="built_in">get_future</span>();         </span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;     </span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));         </span><br><span class="line">  <span class="keyword">return</span> res;                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>Making (std::)promises</li>
</ol>
<p>In applications with large numbers of network connections, it’s
therefore common to have a small number of threads (possibly only one)
handling the connections, with each thread dealing with multiple
connections at once.<strong>std::promise<T></strong> provides a means of
setting a value (of type T) that can later be read through an associated
std::future<T> object.</p>
<p>A std::promise/std::future pair would provide one possible mechanism
for this facility; the waiting thread could block on the future, while
the thread providing the data could use the promise half of the pairing
to set the associated value and make the future ready.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done</span>(connections))       </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="keyword">for</span>(connection_iterator                        </span><br><span class="line">        connection=connections.<span class="built_in">begin</span>(),end=connections.<span class="built_in">end</span>();             </span><br><span class="line">        connection!=end;             </span><br><span class="line">        ++connection)         </span><br><span class="line">    &#123;             </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_incoming_data</span>())                </span><br><span class="line">      &#123;                 </span><br><span class="line">        data_packet data=connection-&gt;<span class="built_in">incoming</span>();                 </span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p=                     </span><br><span class="line">          connection-&gt;<span class="built_in">get_promise</span>(data.id);                    </span><br><span class="line">        p.<span class="built_in">set_value</span>(data.payload);             </span><br><span class="line">      &#125;             </span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_outgoing_data</span>())                </span><br><span class="line">      &#123;                 </span><br><span class="line">        outgoing_packet data=                     </span><br><span class="line">          connection-&gt;<span class="built_in">top_of_outgoing_queue</span>();                 </span><br><span class="line">        connection-&gt;<span class="built_in">send</span>(data.payload);                 </span><br><span class="line">        data.promise.<span class="built_in">set_value</span>(<span class="literal">true</span>);                 </span><br><span class="line">      &#125;         </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>Saving an exception for the future</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::promise&lt;<span class="type">double</span>&gt; some_promise; </span><br><span class="line"><span class="keyword">try</span> &#123;     </span><br><span class="line">  some_promise.<span class="built_in">set_value</span>(<span class="built_in">calculate_value</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) </span><br><span class="line">&#123;     </span><br><span class="line">  some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">logic_error</span>(<span class="string">&quot;foo &quot;</span>)));</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>Waiting from multiple threads</li>
</ol>
<p>If your concurrent code requires that multiple threads can wait for
the same event, <strong>std::shared_future</strong> is all you need.</p>
<figure>
<img src="image-20230106104541937.png" alt="image-20230106104541937" />
<figcaption aria-hidden="true">image-20230106104541937</figcaption>
</figure>
<h2 id="waiting-with-a-time-limit">Waiting with a time limit</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span> std::condition_variable cv; </span></span><br><span class="line"><span class="type">bool</span> done; </span><br><span class="line">std::mutex m; </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_loop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">auto</span> <span class="type">const</span> timeout= std::chrono::steady_clock::<span class="built_in">now</span>()+         std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);     </span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;     </span><br><span class="line">  <span class="keyword">while</span>(!done)     </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk,timeout)==std::cv_status::timeout)             </span><br><span class="line">      <span class="keyword">break</span>;     </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> done; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="using-synchronization-of-operations-to-simplify-code">Using
synchronization of operations to simplify code</h2>
<ol type="1">
<li>Functional programming with futures</li>
</ol>
<p>The term functional programming (FP) refers to a style of programming
where the result of a function call depends solely on the parameters to
that function and doesn’t depend on any external state.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">if</span>(input.<span class="built_in">empty</span>())     </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="keyword">return</span> input;     </span><br><span class="line">  &#125;     </span><br><span class="line">  std::list&lt;T&gt; result;     </span><br><span class="line">  result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),input,input.<span class="built_in">begin</span>());        </span><br><span class="line">  T <span class="type">const</span>&amp; pivot=*result.<span class="built_in">begin</span>();                           </span><br><span class="line">  <span class="keyword">auto</span> divide_point=std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>(),             </span><br><span class="line">                                   [&amp;](T <span class="type">const</span>&amp; t)&#123;<span class="keyword">return</span> t&lt;pivot;&#125;);                   </span><br><span class="line">  std::list&lt;T&gt; lower_part;     </span><br><span class="line">  lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(),input,input.<span class="built_in">begin</span>(),divide_point);                                         </span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(         </span></span></span><br><span class="line"><span class="params"><span class="function">    sequential_quick_sort(std::move(lower_part)))</span></span>;        </span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(         </span></span></span><br><span class="line"><span class="params"><span class="function">    sequential_quick_sort(std::move(input)))</span></span>;         </span><br><span class="line">  result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(),new_higher);          </span><br><span class="line">  result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),new_lower);        </span><br><span class="line">  <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>Synchronizing operations with message passing</li>
</ol>
<p>Each thread is effectively a state machine: when it receives a
message, it updates its state in some manner and maybe sends one or more
messages to other threads.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">card_inserted</span> </span><br><span class="line">&#123;     </span><br><span class="line">  std::string account; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">atm</span> </span><br><span class="line">&#123;     </span><br><span class="line">  messaging::receiver incoming;     </span><br><span class="line">  messaging::sender bank;     </span><br><span class="line">  messaging::sender interface_hardware;     </span><br><span class="line">  <span class="built_in">void</span> (atm::*state)();     </span><br><span class="line">  std::string account;     </span><br><span class="line">  std::string pin;     </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">waiting_for_card</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    interface_hardware.<span class="built_in">send</span>(<span class="built_in">display_enter_card</span>());           </span><br><span class="line">    incoming.<span class="built_in">wait</span>()<span class="comment">//wait for a message to handle</span></span><br><span class="line">      .<span class="built_in">handle</span>&lt;card_inserted&gt;(                 </span><br><span class="line">      [&amp;](card_inserted <span class="type">const</span>&amp; msg)                    </span><br><span class="line">      &#123;                     </span><br><span class="line">        account=msg.account;                     </span><br><span class="line">        pin=<span class="string">&quot;&quot;</span>;                     </span><br><span class="line">        interface_hardware.<span class="built_in">send</span>(<span class="built_in">display_enter_pin</span>());                     </span><br><span class="line">        state=&amp;atm::getting_pin;                 </span><br><span class="line">      &#125;                 </span><br><span class="line">    );     </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getting_pin</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="keyword">public</span>:     </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    state=&amp;atm::waiting_for_card;             </span><br><span class="line">    <span class="keyword">try</span>         </span><br><span class="line">    &#123;             </span><br><span class="line">      <span class="keyword">for</span>(;;)             </span><br><span class="line">      &#123;                 </span><br><span class="line">        (<span class="keyword">this</span>-&gt;*state)();                </span><br><span class="line">      &#125;         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="built_in">catch</span>(messaging::close_queue <span class="type">const</span>&amp;)         </span><br><span class="line">    &#123;         </span><br><span class="line">    &#125;     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>Continuation-style concurrency with the Concurrency TS</li>
</ol>
<p>What you want is a means of saying “When the data is ready, then do
this processing”. This is exactly what <strong>continuations</strong>
give us. Given a future fut, a continuation is added with the call
fut.then(continuation).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::experimental::future&lt;<span class="type">int</span>&gt; find_the_answer; </span><br><span class="line"><span class="keyword">auto</span> fut=<span class="built_in">find_the_answer</span>(); </span><br><span class="line"><span class="keyword">auto</span> fut2=fut.<span class="built_in">then</span>(find_the_question);</span><br></pre></td></tr></table></figure>
<p>Suppose you have a series of time-consuming tasks to do, and you want
to do them asynchronously in order to free up the main thread for other
tasks.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">experimental::future&lt;<span class="type">void</span>&gt; <span class="title">process_login</span><span class="params">(     std::string <span class="type">const</span>&amp; username,std::string <span class="type">const</span>&amp; password)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">spawn_async</span>([=]()&#123;         </span><br><span class="line">    <span class="keyword">return</span> backend.<span class="built_in">authenticate_user</span>(username,password);     &#125;).<span class="built_in">then</span>([](std::experimental::future&lt;user_id&gt; id)&#123;         </span><br><span class="line">    <span class="keyword">return</span> backend.<span class="built_in">request_current_info</span>(id.<span class="built_in">get</span>());     &#125;).<span class="built_in">then</span>([](std::experimental::future&lt;user_data&gt; info_to_display)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;             </span><br><span class="line">      <span class="built_in">update_display</span>(info_to_display.<span class="built_in">get</span>());         </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">catch</span>(std::exception&amp; e)&#123;             </span><br><span class="line">        <span class="built_in">display_error</span>(e);         </span><br><span class="line">      &#125;     </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>Waiting for more than one future</li>
</ol>
<p>Suppose you have a large volume of data to process, and each item can
be processed independently. You pass the set of futures to be waited on
to <strong>when_all</strong>, and it returns a new future that becomes
ready when all the futures in the set are ready.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">experimental::future&lt;FinalResult&gt; <span class="title">process_data</span><span class="params">(     std::vector&lt;MyData&gt;&amp; vec)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="type">size_t</span> <span class="type">const</span> chunk_size=whatever;     </span><br><span class="line">  std::vector&lt;std::experimental::future&lt;ChunkResult&gt;&gt; results;     </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> begin=vec.<span class="built_in">begin</span>(),end=vec.<span class="built_in">end</span>();beg!=end;)&#123;         </span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> remaining_size=end-begin;         </span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> this_chunk_size=std::<span class="built_in">min</span>(remaining_size,chunk_size);         </span><br><span class="line">    results.<span class="built_in">push_back</span>(<span class="built_in">spawn_async</span>(process_chunk,begin,begin+this_chunk_size));         </span><br><span class="line">    begin+=this_chunk_size;     </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="keyword">return</span> std::experimental::<span class="built_in">when_all</span>(<span class="comment">//returns a new future that becomes ready when all the futures in the set are ready</span></span><br><span class="line">    results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>()).<span class="built_in">then</span>(             </span><br><span class="line">    [](std::future&lt;std::vector&lt;std::experimental::future&lt;ChunkResult&gt;&gt;&gt; ready_results)         </span><br><span class="line">    &#123;             </span><br><span class="line">      std::vector&lt;std::experimental::future&lt;ChunkResult&gt;&gt; all_results=ready_results .<span class="built_in">get</span>();             </span><br><span class="line">      std::vector&lt;ChunkResult&gt; v;             </span><br><span class="line">      v.<span class="built_in">reserve</span>(all_results.<span class="built_in">size</span>());             </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; f: all_results)             </span><br><span class="line">      &#123;                 </span><br><span class="line">        v.<span class="built_in">push_back</span>(f.<span class="built_in">get</span>());                </span><br><span class="line">      &#125;             </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">gather_results</span>(v);         </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5" type="1">
<li>Latches and barriers in the Concurrency TS</li>
</ol>
<p>A <strong>latch</strong> is a synchronization object that becomes
ready when its counter is decremented to zero.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> thread_count=...;     </span><br><span class="line">  <span class="function">latch <span class="title">done</span><span class="params">(thread_count)</span></span>;             </span><br><span class="line">  my_data data[thread_count];     </span><br><span class="line">  std::vector&lt;std::future&lt;<span class="type">void</span>&gt; &gt; threads;     </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">unsigned</span> i=<span class="number">0</span>;i&lt;thread_count;++i)         </span><br><span class="line">    threads.<span class="built_in">push_back</span>(std::<span class="built_in">async</span>(std::launch::async,[&amp;,i]&#123;                </span><br><span class="line">      data[i]=<span class="built_in">make_data</span>(i);             </span><br><span class="line">      done.<span class="built_in">count_down</span>();               </span><br><span class="line">      <span class="built_in">do_more_stuff</span>();             </span><br><span class="line">    &#125;));     </span><br><span class="line">  done.<span class="built_in">wait</span>();                       </span><br><span class="line">  <span class="built_in">process_data</span>(data,thread_count);   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>A <strong>barrier</strong> is a reusable synchronization component
used for internal synchronization between a set of threads. When threads
arrive at the barrier, they block until all of the threads involved have
arrived at the barrier, at which point they are all released.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">result_chunk <span class="title">process</span><span class="params">(data_chunk)</span></span>; </span><br><span class="line"><span class="function">std::vector&lt;data_chunk&gt; <span class="title">divide_into_chunks</span><span class="params">(data_block data, <span class="type">unsigned</span> num_threads)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_data</span><span class="params">(data_source &amp;source, data_sink &amp;sink)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> concurrency = std::thread::<span class="built_in">hardware_concurrency</span>();     </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">const</span> num_threads = (concurrency &gt; <span class="number">0</span>) ? concurrency : <span class="number">2</span>;     </span><br><span class="line">  std::<span class="function">experimental::barrier <span class="title">sync</span><span class="params">(num_threads)</span></span>;     </span><br><span class="line">  <span class="function">std::vector&lt;joining_thread&gt; <span class="title">threads</span><span class="params">(num_threads)</span></span>;     </span><br><span class="line">  std::vector&lt;data_chunk&gt; chunks;     </span><br><span class="line">  result_block result;     </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) </span><br><span class="line">  &#123;         </span><br><span class="line">    threads[i] = <span class="built_in">joining_thread</span>([&amp;, i] </span><br><span class="line">                                &#123;             </span><br><span class="line">                                  <span class="keyword">while</span> (!source.<span class="built_in">done</span>()) </span><br><span class="line">                                  &#123;                            </span><br><span class="line">                                    <span class="keyword">if</span> (!i) </span><br><span class="line">                                    &#123;                                     </span><br><span class="line">                                      data_block current_block =source.<span class="built_in">get_next_data_block</span>();</span><br><span class="line">                                      chunks = <span class="built_in">divide_into_chunks</span>(current_block, num_threads);                 </span><br><span class="line">                                    &#125;                 </span><br><span class="line">                                    sync.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">                                    result.<span class="built_in">set_chunk</span>(i, num_threads, <span class="built_in">process</span>(chunks[i]));</span><br><span class="line">                                    sync.<span class="built_in">arrive_and_wait</span>();</span><br><span class="line">                                    <span class="keyword">if</span> (!i) &#123;</span><br><span class="line">                                      sink.<span class="built_in">write_data</span>(std::<span class="built_in">move</span>(result));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="the-c-memory-model-and-operations-on-atomic-types">The C++
memory model and operations on atomic types</h1>
<p>There are three main points in this chapter: <strong>Memory model
basics, Atomic operations and types in C++ and Synchronizing operations
and enforcing ordering</strong>.</p>
<h2 id="memory-model-basics">Memory model basics</h2>
<p>In order to avoid the race condition, there has to be an enforced
ordering between the accesses in the two threads. One way to ensure
there’s a defined ordering is to use mutexes. The other way is to use
the synchronization properties of atomic operations.</p>
<h2 id="atomic-operations-and-types-in-c">Atomic operations and types in
C++</h2>
<ol type="1">
<li>std::atomic_flag</li>
</ol>
<p><strong>std::atomic_flag</strong> is the simplest standard atomic
type, which represents a Boolean flag. Objects of this type can be in
one of two states: set or clear.</p>
<p>Objects of the std::atomic_flag type must be initialized with
ATOMIC_FLAG_INIT. This initializes the flag to a clear state.</p>
<p>Once you have your flag object initialized, there are only three
things you can do with it: destroy it, clear it, or set it and query the
previous value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">clear</span>(std::memory_order_release);    </span><br><span class="line"><span class="type">bool</span> x=f.<span class="built_in">test_and_set</span>(); </span><br></pre></td></tr></table></figure>
<p>The limited feature set makes std::atomic_flag ideally suited to use
as a spinlock mutex.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">spinlock_mutex</span> </span><br><span class="line">&#123;     </span><br><span class="line">  std::atomic_flag flag; </span><br><span class="line">  <span class="keyword">public</span>:     </span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():         </span><br><span class="line">      <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)     </span><br><span class="line">  &#123;&#125;     </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));     </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);     </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>std::atomic<bool></li>
</ol>
<p>The most basic of the atomic integral types is
<strong>std::atomic<bool></strong>. Although it’s still not
copy-constructible or copy-assignable, you can construct it from a
non-atomic bool, so it can be initially true or false, and you can also
assign to instances of std::atomic<bool> from a non-atomic bool.</p>
<p>exchange() member function that allows you to replace the stored
value with a new one of your choosing and atomically retrieve the
original value.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">bool</span>&gt; b; </span><br><span class="line"><span class="type">bool</span> x=b.<span class="built_in">load</span>(std::memory_order_acquire); </span><br><span class="line">b.<span class="built_in">store</span>(<span class="literal">true</span>); </span><br><span class="line">x=b.<span class="built_in">exchange</span>(<span class="literal">false</span>,std::memory_order_acq_rel);</span><br></pre></td></tr></table></figure>
<p><strong>compare-exchange</strong> operation is the cornerstone of
programming with atomic types; it compares the value of the atomic
variable with a supplied expected value and stores the supplied desired
value if they’re equal. If the values aren’t equal, the expected value
is updated with the value of the atomic variable. The return type of the
compare-exchange functions is a bool, which is true if the store was
performed and false otherwise.</p>
<p>For compare_exchange_weak(), the store might not be successful even
if the original value was equal to the expected value. Because
compare_exchange_weak() can fail spuriously, it must typically be used
in a loop.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> expected=<span class="literal">false</span>; </span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="type">bool</span>&gt; b; <span class="comment">// set somewhere else </span></span><br><span class="line"><span class="keyword">while</span>(!b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure>
<p>On the other hand, compare_exchange_strong() is guaranteed to return
false only if the value wasn’t equal to the expected value.</p>
<h2 id="synchronizing-operations-and-enforcing-ordering">Synchronizing
operations and enforcing ordering</h2>
<p>Use atomic<int> for synchronizing: LeetCode 1195</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FizzBuzz</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    atomic&lt;<span class="type">int</span>&gt; num_=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FizzBuzz</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printFizz() outputs &quot;fizz&quot;.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fizz</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFizz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!(num_&gt;<span class="keyword">this</span>-&gt;n||num_%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;num_%<span class="number">5</span>!=<span class="number">0</span>))this_thread::<span class="built_in">yield</span>();</span><br><span class="line">            <span class="comment">//use num_ to decide whether this thread should run or block here</span></span><br><span class="line">            <span class="keyword">if</span>(num_&gt;<span class="keyword">this</span>-&gt;n)<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printFizz</span>();</span><br><span class="line">            num_++;</span><br><span class="line">            <span class="keyword">if</span>(num_&gt;<span class="keyword">this</span>-&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="designing-lock-based-concurrent-data-structures">Designing
lock-based concurrent data structures</h1>
<p>designing a data structure for concurrency means that multiple
threads can access the data structure concurrently, either performing
the same or distinct operations, and each thread will see a
self-consistent view of the data structure. No data will be lost or
corrupted, all invariants will be upheld, and there’ll be no problematic
race conditions.</p>
<h2 id="lock-based-concurrent-data-structures">Lock-based concurrent
data structures</h2>
<p>The design of lock-based concurrent data structures is all about
ensuring that the right mutex is locked when accessing the data and that
the lock is held for the minimum amount of time.</p>
<ol type="1">
<li>A thread-safe stack using locks</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span> </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span>: std::exception </span><br><span class="line">&#123;     </span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">private</span>:     std::stack&lt;T&gt; data;     </span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m; <span class="keyword">public</span>:     </span><br><span class="line">  <span class="built_in">threadsafe_stack</span>()&#123;&#125;     </span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp; other)     </span><br><span class="line">  &#123;         </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;         </span><br><span class="line">    data=other.data;     </span><br><span class="line">  &#125;     </span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;     </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span>     </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;         </span><br><span class="line">    data.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));        </span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span>     </span></span><br><span class="line"><span class="function">  </span>&#123;         </span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;         </span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="type">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::make_shared&lt;T&gt;(std::move(data.top())))</span></span>;</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">    value=std::<span class="built_in">move</span>(data.<span class="built_in">top</span>());</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The stack doesn’t provide any means of waiting for an item to be
added, so if a thread needs to wait, it must periodically call empty(),
or call pop() and catch the empty_stack exceptions.</p>
<ol start="2" type="1">
<li>A thread-safe queue using locks and condition variables</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_queue</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond; </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>()     &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The new wait_and_pop() functions are a solution to the problem of
waiting for a queue entry that you saw with the stack; rather than
continuously calling empty(), the waiting thread can call wait_and_pop()
and the data structure will handle the waiting with a condition
variable. The call to data_cond.wait() won’t return until the underlying
queue has at least one element, so you don’t have to worry about the
possibility of an empty queue at this point in the code.</p>
<h2 id="designing-more-complex-lock-based-data-structures">Designing
more complex lock-based data structures</h2>
<p>Writing a thread-safe list using locks</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_list</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::shared_ptr&lt;T&gt; data;</span><br><span class="line">    std::unique_ptr&lt;node&gt; next;</span><br><span class="line">    <span class="built_in">node</span>():</span><br><span class="line">      <span class="built_in">next</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(T <span class="type">const</span>&amp; value):</span><br><span class="line">    <span class="built_in">data</span>(std::<span class="built_in">make_shared</span>&lt;T&gt;(value))</span><br><span class="line">    &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  node head;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_list</span>()&#123;&#125;</span><br><span class="line">  ~<span class="built_in">threadsafe_list</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">remove_if</span>([](node <span class="type">const</span>&amp;)&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">threadsafe_list</span>(threadsafe_list <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  threadsafe_list&amp; <span class="keyword">operator</span>=(threadsafe_list <span class="type">const</span>&amp; other)=<span class="keyword">delete</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T <span class="type">const</span>&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;node&gt; <span class="title">new_node</span><span class="params">(<span class="keyword">new</span> node(value))</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;</span><br><span class="line">    new_node-&gt;next=std::<span class="built_in">move</span>(head.next);<span class="comment">//acquire the lock on the mutex for the head node in order to get the appropriate next value</span></span><br><span class="line">    head.next=std::<span class="built_in">move</span>(new_node);<span class="comment">//insert the node at the front of the list by setting head.next to point to your new node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">for_each</span><span class="params">(Function f)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    node* current=&amp;head;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(head.m)</span></span>;<span class="comment">// lock the mutex on the head node to obtain the pointer to the next node</span></span><br><span class="line">    <span class="keyword">while</span>(node* <span class="type">const</span> next=current-&gt;next.<span class="built_in">get</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">next_lk</span><span class="params">(next-&gt;m)</span></span>;</span><br><span class="line">      lk.<span class="built_in">unlock</span>();<span class="comment">//Once you have the lock on that node, you can release the lock on the previous node</span></span><br><span class="line">      <span class="built_in">f</span>(*next-&gt;data);</span><br><span class="line">      current=next;</span><br><span class="line">      lk=std::<span class="built_in">move</span>(next_lk);<span class="comment">//move the ownership of the lock from next_lk out to lk</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://yaohaizhou.com">Yaohai Zhou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/">http://yaohaizhou.com/2023/01/05/Cpp-Concurrency-in-Action-Note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Book/">Book</a></div><div class="post_share"><div class="social-share" data-image="/2023/01/05/Cpp-Concurrency-in-Action-Note/CCIA.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/17/Distributed-Systems-MIT6-824-Notes/"><img class="prev-cover" src="/2023/01/17/Distributed-Systems-MIT6-824-Notes/gfs.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Distributed Systems MIT6.824 Notes</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/17/Vectorized-Similarity-Search-in-Multi-modal-Databases/"><img class="next-cover" src="/2022/12/17/Vectorized-Similarity-Search-in-Multi-modal-Databases/db.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Vectorized Similarity Search in Multi-modal Databases</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yaohai Zhou</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zyhhhy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zyhhhy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zyh828482@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Yaohai is a M.S. candidate with over 4 years of programming experience in various areas, including backend development, cloud & distributed systems, database and machine learning; solid programming skills in C++, Python, Go, Java and SQL; hands-on experience with React, PyTorch and GCP; strong knowledge of algorithms, data structures.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch3-sharing-data-between-threads"><span class="toc-number">1.</span> <span class="toc-text">Ch3: Sharing data between
threads</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#problems-with-sharing-data-between-threads"><span class="toc-number">1.1.</span> <span class="toc-text">Problems with
sharing data between threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#protecting-shared-data-with-mutexes"><span class="toc-number">1.2.</span> <span class="toc-text">Protecting shared data with
mutexes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alternative-facilities-for-protecting-shared-data"><span class="toc-number">1.3.</span> <span class="toc-text">Alternative
facilities for protecting shared data</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ch4-synchronizing-concurrent-operations"><span class="toc-number">2.</span> <span class="toc-text">Ch4: Synchronizing
concurrent operations</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#waiting-for-an-event-or-other-condition"><span class="toc-number">2.1.</span> <span class="toc-text">Waiting for an event or
other condition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waiting-for-one-off-events-with-futures"><span class="toc-number">2.2.</span> <span class="toc-text">Waiting for one-off
events with futures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#waiting-with-a-time-limit"><span class="toc-number">2.3.</span> <span class="toc-text">Waiting with a time limit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#using-synchronization-of-operations-to-simplify-code"><span class="toc-number">2.4.</span> <span class="toc-text">Using
synchronization of operations to simplify code</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#the-c-memory-model-and-operations-on-atomic-types"><span class="toc-number">3.</span> <span class="toc-text">The C++
memory model and operations on atomic types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-model-basics"><span class="toc-number">3.1.</span> <span class="toc-text">Memory model basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-operations-and-types-in-c"><span class="toc-number">3.2.</span> <span class="toc-text">Atomic operations and types in
C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronizing-operations-and-enforcing-ordering"><span class="toc-number">3.3.</span> <span class="toc-text">Synchronizing
operations and enforcing ordering</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#designing-lock-based-concurrent-data-structures"><span class="toc-number">4.</span> <span class="toc-text">Designing
lock-based concurrent data structures</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-based-concurrent-data-structures"><span class="toc-number">4.1.</span> <span class="toc-text">Lock-based concurrent
data structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#designing-more-complex-lock-based-data-structures"><span class="toc-number">4.2.</span> <span class="toc-text">Designing
more complex lock-based data structures</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/17/Distributed-Systems-MIT6-824-Notes/" title="Distributed Systems MIT6.824 Notes"><img src="/2023/01/17/Distributed-Systems-MIT6-824-Notes/gfs.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Distributed Systems MIT6.824 Notes"/></a><div class="content"><a class="title" href="/2023/01/17/Distributed-Systems-MIT6-824-Notes/" title="Distributed Systems MIT6.824 Notes">Distributed Systems MIT6.824 Notes</a><time datetime="2023-01-17T23:22:11.000Z" title="Created 2023-01-17 15:22:11">2023-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/05/Cpp-Concurrency-in-Action-Note/" title="Cpp Concurrency in Action Note"><img src="/2023/01/05/Cpp-Concurrency-in-Action-Note/CCIA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cpp Concurrency in Action Note"/></a><div class="content"><a class="title" href="/2023/01/05/Cpp-Concurrency-in-Action-Note/" title="Cpp Concurrency in Action Note">Cpp Concurrency in Action Note</a><time datetime="2023-01-06T00:43:08.000Z" title="Created 2023-01-05 16:43:08">2023-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/17/Vectorized-Similarity-Search-in-Multi-modal-Databases/" title="Vectorized Similarity Search in Multi-modal Databases"><img src="/2022/12/17/Vectorized-Similarity-Search-in-Multi-modal-Databases/db.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vectorized Similarity Search in Multi-modal Databases"/></a><div class="content"><a class="title" href="/2022/12/17/Vectorized-Similarity-Search-in-Multi-modal-Databases/" title="Vectorized Similarity Search in Multi-modal Databases">Vectorized Similarity Search in Multi-modal Databases</a><time datetime="2022-12-17T18:30:37.000Z" title="Created 2022-12-17 10:30:37">2022-12-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Yaohai Zhou</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>